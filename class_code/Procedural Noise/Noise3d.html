<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" > 

<title>Procedural Noise</title>

<script id="vertex-shader" type="x-shader/x-vertex">
precision highp float; // use high precision

attribute vec4 vPosition;
varying vec2 pos;

void main(){
    pos = vPosition.xy;
	gl_Position = vPosition;
}
</script>

<script id="fragment-shader" type="x-shader/x-fragment">

precision highp float; // use high precision
varying vec2 pos;
uniform float t; // time in seconds
uniform mat4 TB;

#define PI 3.14159
#define SALT  0.11
#define SALT1 0.59
#define SALT2 0.75
#define SALT3 0.86

vec3 hsv2rgb(vec3 c) {
  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 mapToColor(float h){
	float s = 1.0;
	float v = 1.0;
	return hsv2rgb(vec3(h,s,v));
}


float random(vec3 v, float salt){
	// returns a value in [0,1)
	float a = 5678.1234; 
	vec3 b = vec3(12.3456, 78.910, 11.1213);
	float c = 1.1235+salt;
	return fract(a*sin(dot(b,v)+c));
}

float random(vec3 v){
	// returns a value in [0,1)
	return random(v, SALT);
}


vec3 randvec(vec3 v){
	float z = 2.0*random(v,SALT1) -1.0;     // random height z \in [-1,1]
	float r = sqrt(1.0 - z*z);              // r: radius of circle at height z
	float theta = 2.0*PI*random(v,SALT2); // random angle theta \in [0, 2*PI]
	return vec3(r*cos(theta), r*sin(theta), z);
}

float alpha(float t){ // fading fn, similar to smoothstep
	return ((6.0*t-15.0)*t + 10.0)*t*t*t;
}

float valueNoise(vec3 p){
	vec3 p0 = floor(p);
	float l0 = random(p0);
	float l1 = random(p0 + vec3(0.0, 0.0, 1.0));
	float l2 = random(p0 + vec3(0.0, 1.0, 0.0));
    float l3 = random(p0 + vec3(0.0, 1.0, 1.0));
    float l4 = random(p0 + vec3(1.0, 0.0, 0.0));
    float l5 = random(p0 + vec3(1.0, 0.0, 1.0));
    float l6 = random(p0 + vec3(1.0, 1.0, 0.0));
    float l7 = random(p0 + vec3(1.0, 1.0, 1.0));
	
	vec3 t = fract(p);
	float a = t.x, b = t.y, c = t.z;
	float a0 = alpha(1.0-a), a1 = alpha(a);
	float b0 = alpha(1.0-b), b1 = alpha(b);
	float c0 = alpha(1.0-c), c1 = alpha(c);
	 
	return a0*b0*c0*l0 + a0*b0*c1*l1 + a0*b1*c0*l2 + a0*b1*c1*l3 +
	       a1*b0*c0*l4 + a1*b0*c1*l5 + a1*b1*c0*l6 + a1*b1*c1*l7;
}

float gradientNoise(vec3 p){

	vec3 p0 = floor(p);
	vec3 p1 = p0 + vec3(0.0, 0.0, 1.0);
	vec3 p2 = p0 + vec3(0.0, 1.0, 0.0);
    vec3 p3 = p0 + vec3(0.0, 1.0, 1.0);
    vec3 p4 = p0 + vec3(1.0, 0.0, 0.0);
    vec3 p5 = p0 + vec3(1.0, 0.0, 1.0);
    vec3 p6 = p0 + vec3(1.0, 1.0, 0.0);
    vec3 p7 = p0 + vec3(1.0, 1.0, 1.0);

	float l0 = random(p0) + dot( p - p0, randvec(p0) );
	float l1 = random(p1) + dot( p - p1, randvec(p1) );
	float l2 = random(p2) + dot( p - p2, randvec(p2) );
	float l3 = random(p3) + dot( p - p3, randvec(p3) );
	float l4 = random(p4) + dot( p - p4, randvec(p4) );
	float l5 = random(p5) + dot( p - p5, randvec(p5) );
	float l6 = random(p6) + dot( p - p6, randvec(p6) );
	float l7 = random(p7) + dot( p - p7, randvec(p7) );

	vec3 t = fract(p);
	float a = t.x, b = t.y, c = t.z;
	float a0 = alpha(1.0-a), a1 = alpha(a);
	float b0 = alpha(1.0-b), b1 = alpha(b);
	float c0 = alpha(1.0-c), c1 = alpha(c);
	
	return a0*b0*c0*l0 + a0*b0*c1*l1 + a0*b1*c0*l2 + a0*b1*c1*l3 +
	       a1*b0*c0*l4 + a1*b0*c1*l5 + a1*b1*c0*l6 + a1*b1*c1*l7;
}

#define OCTAVES 8
float fbm(vec3 p){
	float a = 1.0, s = 0.0;
	for(int i = 0; i < OCTAVES; ++i){
		a *= 2.0;
		s += gradientNoise(a*p)/a;
	}
	return s;
}

float fbmVN(vec3 p){
	float a = 1.0, s = 0.0;
	for(int i = 0; i < OCTAVES; ++i){
		a *= 2.0;
		s += valueNoise(a*p)/a;
	}
	return s;
}

float turbulence(vec3 p){
	/*	Similar to fbm but uses absolute value of noise fn.
		This introduces discontinuties in the derivative.	*/
	float a = 1.0, s = 0.0;
	for(int i = 0; i < OCTAVES; ++i){
		a *= 2.0;
		s += abs(gradientNoise(a*p))/a; 
	}
	return s;
}

float fff(vec3 p){
	return fbm(p + 1.0/4.0 + fbm(p + fbm(p)));
}


void main(){ 
    float r = 0.7;
    float l = length(pos);
    if(l > r) discard;
	vec4 q = TB*vec4(pos, sqrt(r*r-l*l),1);
	vec3 p = q.xyz;
	
	vec3 color;

	//color = mapToColor(random(p));
	//color = mapToColor(valueNoise(p)); 
	//color = mapToColor(fbmVN(p));
	//color = mapToColor(gradientNoise(p));
	//color = vec3(gradientNoise(p)); /* BW color*/
	//color = mapToColor(fbm(p));
	color = mapToColor(fff(p));
	//color = mapToColor(turbulence(p));
	//color = example1(p);
	//color  = example2(p);
	//color = example3(p);
	//color = example4(p);

	gl_FragColor = vec4(color,1.0); 

}
</script>

<script type="text/javascript" src="../Common/webgl-utils.js"></script>
<script type="text/javascript" src="../Common/initShaders.js"></script>
<script type="text/javascript" src="../Common/MV.js"></script>
<script type="text/javascript" src="../Common/Utils/Trackball.js"></script>
<script type="text/javascript" src="Noise3d.js"></script>
</head>

<body style="background-color:grey;">
<canvas id="gl-canvas" width="512" height="512">
  HTML5 Canvas not supported!
</canvas>
</body>
</html>


<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" > 

<title>GPU Ray Tracer</title>

<script type="text/javascript" src="../Common/webgl-utils.js"></script>
<script type="text/javascript" src="../Common/initShaders.js"></script>
<script type="text/javascript" src="../Common/MV.js"></script>
<script type="text/javascript" src="../Common/Utils/Texture.js"></script>
<script type="text/javascript" src="../Common/Utils/Trackball.js"></script>
<script type="text/javascript" src="gpuRayTracer.js"></script>

<script id="vertex-shader" type="x-shader/x-vertex">
precision mediump float;
uniform float t;
attribute vec2 vPosition;
varying vec2 fPosition;
void main(){
    fPosition = vPosition;
    gl_Position = vec4(vPosition, 0.0, 1.0);
}
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
precision mediump float;
varying vec2 fPosition;
uniform float t;
uniform int nx, ny;
uniform int antialias;
uniform mat4 MM;

uniform sampler2D diffuseMapSampler;

const float MAX = 1000.0;
const float pi = 3.1415926;
const int trace_depth = 3;

const vec3 background = vec3(0.0, 0.0, 0.0);
const vec3 ambient = vec3(0.1,0.1,0.1);

struct Light{
    vec3 position;
    vec3 color;
    float intensity;
};
const int nLights = 3;
Light L[nLights];

struct Material{
    vec3 color;
    float reflectivity;
    float shininess;
};
const int nMaterials = 4;
Material M[nMaterials];

struct Sphere{
    int id;
    vec3 c;   // center
    float r;  // radius
    Material mat;
};
const int nSpheres = 4;
Sphere S[nSpheres];


struct Camera{
    vec3 location;
    vec3 up;
    vec3 lookAt;
    float fov; 
} Cam;

struct Ray{ // e + td, t>=0
    vec3 e;
    vec3 d; 
};

struct Intersection{
    bool yes;   // indicates whether there is an intersection
    float t;
    Sphere sph;
};


float hash(float x){ // returns a "random" float in [0,1]
    return fract(sin(12.9898*x+78.233)*43758.5453);
}

vec2 randvec2(float salt){// returns a vec2 in [-1,1]^2
    return 2.0*vec2(hash(salt), hash(salt+pi))-1.0;
}

Ray pixelRay(float salt){
   
    // salt is used for random perturbation

    float aspect = float(nx)/float(ny);
    float near = 1.0; // distance to near plane i.e., projection plane
	float top = near*tan(Cam.fov*pi/360.0); // bottom = -top
	float right = top*aspect;               // left = -right

	// compute camera basis 
	vec3 w = normalize(Cam.location- Cam.lookAt);
	vec3 u = normalize(cross(Cam.up,w));
	vec3 v = cross(w,u);

	float ucomp = right*fPosition.x; 
	float vcomp = top*fPosition.y;   
	float wcomp = -near;

    if(salt != 0.0) { 
        vec2 rnd = randvec2(salt) * vec2(right/float(nx), top/float(ny));
        ucomp += rnd.x; vcomp += rnd.y;
    }
   
    return Ray(Cam.location, ucomp*u + vcomp*v + wcomp*w);
}


float intersect(Ray ray, Sphere sph){
    float t = MAX;
    vec3 x = ray.e - sph.c; 
    float A = dot(ray.d, ray.d);
    float B = 2.0*dot(x, ray.d);
    float C = dot(x,x) - sph.r*sph.r;
    float D = B*B - 4.0*A*C;

    if(D>=0.0){
        float S  = sqrt(D);
        float t1 = (-B - S)/(2.0*A);
        float t2 = (-B + S)/(2.0*A);

        if(t1 >= 0.0) t = t1;
        if((t2 >= 0.0) && (t2<t1)) t = t2;
    }
    
    return t;
}

Intersection hit(Ray ray){ 
    float t = MAX; 
    Material mat;
    Sphere sph;
    for(int j = 0; j<nSpheres; ++j){
        float x = intersect(ray, S[j]);
        if(x<t) { t = x; sph = S[j];}
    }
    vec3 col = vec3(0.0, 1.0, 0.0);
    return Intersection((t<MAX), t, sph);
}

vec3 getColor(vec3 pos, Sphere sph){
    vec3 color;
    if(sph.id == 0){ // texture mapping for Sphere S[0]
       pos = vec3(MM*vec4(pos, 1.0)) - sph.c;
       float theta = atan(length(pos.xy),pos.z);
       float phi = atan(pos.y, pos.x);
       if(phi<0.0) phi += 2.0*pi;
       vec2 tc = vec2(phi/(2.0*pi), 1.0 - theta/pi); 
       color = texture2D( diffuseMapSampler, tc).rgb;
    }
    else{
        color = sph.mat.color;
    }

    return color;
}


vec3 shade(vec3 position, vec3 normal, vec3 viewDir, Sphere sph){

	vec3 final_color = vec3(0,0,0);
	vec3 diffuse = ambient;
	vec3 specular = vec3(0,0,0);


	for(int i = 0; i< nLights; ++i){
		Light l = L[i];
		vec3 toLight  = l.position - position;
		vec3 lightDir = normalize(toLight);
		Ray shadowRay = Ray(position, lightDir); 
		Intersection I = hit(shadowRay);
		if(I.t > length(toLight)){ 
			float diffuseIntensity = l.intensity*max(dot(lightDir, normal),0.0);
			diffuse += diffuseIntensity*l.color; 
			vec3 halfvector = normalize(viewDir + lightDir);
			float specularIntensity = pow(max(dot(halfvector, normal), 0.0), sph.mat.shininess);
			specular += specularIntensity*l.color;
		}
	}

	final_color += diffuse*getColor(position, sph) + specular;

	return final_color;
}

vec3 trace(Ray ray){

	vec3 color = vec3(0,0,0);
	float s=1.0; 
	float epsilon = 0.001; 

	for(int i=0; i<=trace_depth; ++i) {

		Intersection I = hit(ray);

		if(I.yes){
		    vec3 ipoint = ray.e + I.t*ray.d;
			vec3 normal = normalize(ipoint - I.sph.c);
			color += s*shade(ipoint+epsilon*normal, normal, -ray.d, I.sph);

			// Note: we move an epsilon distance from ipoint in the direction of the
			// normal to prevent the reflected ray from intersecting the same sphere
			// due to precision errors.

			vec3 reflected_dir = ray.d-2.0*dot(ray.d, normal)*normal; 
			Ray reflected_ray = Ray(ipoint, reflected_dir);
			s*= I.sph.mat.reflectivity;
			ray = reflected_ray;
		}
		else{
		    color += s*background;
		    break;
		}
	}
	
	return color;
}


void setup(){
    Cam = Camera(vec3(0.0,0.0,3.5), vec3(0.0,1.0, 0.0), vec3(0.0,0.0,0.0), 90.0);
    
    L[0] = Light(vec3(-2.0,10.0,0.0), vec3(1.0,1.0,1.0), 0.6);
    L[1] = Light(vec3(2.0,-1.0,10.0), vec3(1.0,1.0,1.0), 0.5);
    L[2] = Light(vec3(2.0,4.0,-5.0), vec3(1.0,1.0,1.0), 0.7);

    M[0] = Material(vec3(0.8,0.8,0.8), 0.8, 2400.0);
    M[1] = Material(vec3(1.0,0.0,1.0), 0.7, 100.0);
    M[2] = Material(vec3(0.1,0.7,0.2), 0.6, 150.0);
    M[3] = Material(vec3(0.6,0.1,0.1), 0.5, 50.0);

    float r = 1.5;
    
    S[0] = Sphere(0, vec3(0.6,0,0), 1.3, M[0]);
    S[1] = Sphere(1, vec3(-0.6,0.8,1.5)*(2.5*sin(0.3*t)-1.0), 0.5, M[1]);
    S[2] = Sphere(2, vec3(-1.2,-0.7,1.0), 0.6, M[2]);
    S[3] = Sphere(3, vec3(r*cos(0.3*t),0.4,r*sin(0.3*t)+0.3), 0.3, M[3]);
}


void main(){
    setup();
    const int N = 30;
    vec3 color;
    if(antialias == 1){
        color = vec3(0.0);
        for(int i=0; i<N; ++i){
            color += trace(pixelRay(float(i)));
        }
        color /= float(N);
    }
    else{
        color += trace(pixelRay(0.0));
    }

    gl_FragColor = vec4(color, 1.0);
}

</script>

</head>

<body>
<canvas id="gl-canvas" width="700" height="700">
  HTML5 Canvas not supported!
</canvas>
<br>
<button id="btn"> Toggle Antialiasing </button> <br>
To see the effect of antialiasing, look closely at the boundary of the spheres.
<br><b> Use the mouse to rotate the central sphere. </b>
</body>
</html>

